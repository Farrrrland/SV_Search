### Task1

两份文件 ref.festa 和sv.fasta 分别表示原基因和突变基因。目标突变类型为 INS，DEL，INV，TRA，DUP。

#### 代码结构

main.py 用于处理数据并输出结果。

首先读出festa文件中的数据，转化为 string 类型分别储存在 SV 和 REF 字典中，索引为基因序列编号。

其次遍历 SV 和 REF 中的对应字符串，调用 `process (key)` 函数进行处理。

 `process (key)` 函数中设置两个指针，遍历比较 sv 串和 ref 串。遇到每个适配的位置时调用 `greedy_search` 函数，采用贪心的方式从适配点最小突变距离开始到最大突变距离向后遍历寻找最大匹配长度（即假设突变在某点结束后，后续串能够匹配的最大长度）。考虑到数据中一条链的长度为 2*10^6 而一共只有 50 次突变且突变长度被限制在 [min=50, max=1000] 之间，可以预见相邻的突变之间的间隔相较于突变长度而言是很大的。故贪心算法可以得出比较准确的结果。

`greedy_search` 函数中每次向后寻找最大匹配，对失配点后 [min, max] 之间的每一个点，都根据不同的 case 进行了当前匹配长度的计算（调用 `match` 函数完成）。动态地维护 max_match 作为当前匹配的最大长度，以及 case 描述最大匹配对应的变异情况（case 为1 ~ 5 分别代表五种不同的变异）。全部做完后返回 `case, refpos1, refpos2, svpos1, svpos2, max_match` 分别表示变异类型，原串变异起始位置，原串变异起始位置+变异长度，sv串变异起始位置，sv串变异起始位置+变异长度，最大匹配长度。在`greedy_search` 函数中根据不同的 case 输出结果，并跳过计算好的最大匹配长度，更新两个串上的指针继续迭代。

注意到由于TRA类型的变异是两段等长基因串的互换（这里PJ描述中提到的是一个串中的一段删除后添加到另一串的某个位置，是不准确的，与测试数据产生较大出入。故以提供的测试数据和答案样例为准，能够通过check得到分数），要等待所有检查完成后才能确定，故将预期为 TRA 类型（最大匹配长度为两串同时向后遍历时得到，且判断不是INV类型变异）的变异存到 TRA 数组中，最后进行比较，若其中存在一对元素，两个原串对应位置的字符串hash值都和另一个sv串对应位置的hash值相同，则认为是TRA类型变异输出。

#### 性能优化

在寻找最大匹配的过程中进行了优化，考虑到最大突变长度为 max=1000 ，`match` 函数返回的最大值为 max = 1000 ，且在动态更新最大匹配长度时若长度为 1000 则默认找到了最大匹配，不再向后匹配，直接返回对应的变异信息。由于超过1000的匹配字符串不可能是突变产生的并且相邻突变之间的距离较大，所以该优化对结果的正确性影响可以忽略不计。该优化对于算法性能有极大提高，经测试，对于给定数据，优化后的算法性能是未优化前的 150 倍左右。

#### 测试结果

算法将变异信息输出到 sv.bed 文件中。在测试数据上运行后使用 check.cpp 程序与给定的答案比对，能够得到满分。

